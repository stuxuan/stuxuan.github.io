<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mxwu">





<title>【数据结构】5.大根堆和左高树 | xuan&#39;s Blogs</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">xuan&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">xuan&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">【数据结构】5.大根堆和左高树</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mxwu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 12, 2023&nbsp;&nbsp;17:08:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="1-大根堆"><a href="#1-大根堆" class="headerlink" title="1.大根堆"></a>1.大根堆</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>　　<strong>大根树：</strong>树中的每一个节点的值都大于或等于其子节点的值</p>
<p>　　<strong>大根堆：</strong>既是大根树又是完全二叉树（增加了完全二叉树的限制条件）所以下图中只有(a)和(c)是大根堆</p>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231010162138156-285865212.png" width="60%"></img></div>

<h2 id="1-2-大根堆的插入（数组实现）"><a href="#1-2-大根堆的插入（数组实现）" class="headerlink" title="1.2 大根堆的插入（数组实现）"></a>1.2 大根堆的插入（数组实现）</h2><p>　　假设在下面大根堆中插入一个元素9，插入步骤如下，时间复杂度为O(height)&#x3D;O(logn)</p>
<ul>
<li>尝试插入在6号位置，如果新的元素小于3号位置，则插入；否则把3号位置的元素向下移动到6号位置</li>
<li>尝试插入在3号位置，如果新的元素小于1号元素，则插入；否则把1号位置的元素向下移动到3号位置，循环终止</li>
</ul>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231010163207666-12500325.png" width="90%"></img></div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为theElement寻找插入位置, currentNode从新叶子节点开始向上移动</span></span><br><span class="line"><span class="type">int</span> currentNode = ++heapSize;</span><br><span class="line"><span class="keyword">while</span> (currentNode != <span class="number">1</span> &amp;&amp; heap[currentNode / <span class="number">2</span>] &lt; theElement)</span><br><span class="line">&#123;</span><br><span class="line">    heap[currentNode] = heap[currentNode / <span class="number">2</span>]; <span class="comment">// 元素向下移动</span></span><br><span class="line">    currentNode /= <span class="number">2</span>;                          <span class="comment">// currentNode移动到他的双亲</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heap[currentNode] = theElement;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-大根堆的出队"><a href="#1-3-大根堆的出队" class="headerlink" title="1.3 大根堆的出队"></a>1.3 大根堆的出队</h2><p>　　出队元素是最大的元素，也就是根节点，我们首先将1号元素删除，然后拿到最后一个元素，从上向下做插入的操作，时间复杂度为O(height)&#x3D;O(logn)</p>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231010164622254-1446016205.png" width="50%"></img></div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从根节点开始, 为最后一个元素查找插入位置</span></span><br><span class="line"><span class="type">int</span> currentNode = <span class="number">1</span>;    <span class="comment">// 当前双亲节点</span></span><br><span class="line"><span class="type">int</span> child = <span class="number">2</span>;          <span class="comment">// 当前孩子节点</span></span><br><span class="line"><span class="keyword">while</span> (child &lt;= heapSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// heap[child] 应该是 currentNode 更大的孩子</span></span><br><span class="line">    <span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>])</span><br><span class="line">        child++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比 lastElement 是否可以插入到 currentNode</span></span><br><span class="line">    <span class="keyword">if</span> (lastElement &gt;= heap[child])</span><br><span class="line">        <span class="keyword">break</span>;   <span class="comment">// 可以插入则直接结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可以插入则继续循环</span></span><br><span class="line">    heap[currentNode] = heap[child]; <span class="comment">// 子节点向上移动</span></span><br><span class="line">    currentNode = child;             <span class="comment">// 当前指向节点移动到子节点</span></span><br><span class="line">    child *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">heap[currentNode] = lastElement;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-大根堆的初始化"><a href="#1-4-大根堆的初始化" class="headerlink" title="1.4 大根堆的初始化"></a>1.4 大根堆的初始化</h2><p>　　<strong>自下而上：</strong>从最后一个元素开始对比，到第一个元素结束，具体步骤如下</p>
<ul>
<li>①找到孩子节点 2 和 7 中更大的元素，接下来与其双亲节点对比，7 更大所以交换 5 和 7 的位置</li>
<li>①找到孩子节点 7 和 6 中更大的元素，接下来与其双亲节点对比，7 更大所以交换 1 和 7 的位置；②找到孩子节点 2 和 5 中更大的元素，接下来与其双亲节点对比，5 更大所以交换 1 和 5 的位置</li>
</ul>
<p>　　这里的循环包括两个步骤，第一个步骤是从下到上交换一次，第二个步骤是从上到下再检查一遍</p>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231010161834664-2008682224.png" width="70%"></img></div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> root = heapSize / <span class="number">2</span>; root &gt;= <span class="number">1</span>; root--)</span><br><span class="line">&#123;</span><br><span class="line">    T rootElement = heap[root];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给元素 rootElement 寻找位置</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * root; <span class="comment">// 孩子 child 的双亲是 rootElement 的位置</span></span><br><span class="line">    <span class="comment">// 确定 rootElement 的位置</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= heapSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// heap[child] 找到孩子里更大的那一个</span></span><br><span class="line">        <span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否可以把 rootElement 插入到该位置</span></span><br><span class="line">        <span class="keyword">if</span> (rootElement &gt;= heap[child])</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不可以</span></span><br><span class="line">        heap[child / <span class="number">2</span>] = heap[child]; <span class="comment">// 孩子向上移动</span></span><br><span class="line">        child *= <span class="number">2</span>;                    <span class="comment">// 下移一层查看</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap[child / <span class="number">2</span>] = rootElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-完整代码"><a href="#1-5-完整代码" class="headerlink" title="1.5 完整代码"></a>1.5 完整代码</h2><h3 id="1-5-1-优先级队列抽象父类"><a href="#1-5-1-优先级队列抽象父类" class="headerlink" title="1.5.1 优先级队列抽象父类"></a>1.5.1 优先级队列抽象父类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">maxPriorityQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">maxPriorityQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回优先级最高的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> T&amp; <span class="title">top</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 弹出优先级最高的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-大根堆的数组实现"><a href="#1-5-2-大根堆的数组实现" class="headerlink" title="1.5.2 大根堆的数组实现"></a>1.5.2 大根堆的数组实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maxPriorityQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">maxHeap</span> : <span class="keyword">public</span> maxPriorityQueue&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> heapSize;       <span class="comment">// 队列中的元素数量</span></span><br><span class="line">    <span class="type">int</span> arrayLength;    <span class="comment">// 队列的容量</span></span><br><span class="line">    T* heap;            <span class="comment">// 元素数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">maxHeap</span>(<span class="type">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">maxHeap</span>() &#123; <span class="keyword">delete</span>[] heap; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heapSize == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heapSize; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">// 返回优先级最大的元素</span></span><br><span class="line">        <span class="keyword">if</span> (heapSize == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(T*, <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deactivateArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap = <span class="literal">NULL</span>; arrayLength = heapSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeLength</span><span class="params">(T*&amp; a, <span class="type">int</span> oldLength, <span class="type">int</span> newLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 改变数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (newLength &lt; <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    T* temp = <span class="keyword">new</span> T[newLength];              <span class="comment">// 新的数组</span></span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">min</span>(oldLength, newLength);  <span class="comment">// 需要复制的元素个数</span></span><br><span class="line">    <span class="built_in">copy</span>(a, a + number, temp);</span><br><span class="line">    <span class="keyword">delete</span>[] a;                              <span class="comment">// 清理内存</span></span><br><span class="line">    a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">maxHeap&lt;T&gt;::<span class="built_in">maxHeap</span>(<span class="type">int</span> initialCapacity)</span><br><span class="line">&#123;<span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造大根堆的数量必须大于1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arrayLength = initialCapacity + <span class="number">1</span>;</span><br><span class="line">    heap = <span class="keyword">new</span> T[arrayLength];</span><br><span class="line">    heapSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> maxHeap&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;<span class="comment">// 将元素插入到大根堆</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (heapSize == arrayLength - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">changeLength</span>(heap, arrayLength, <span class="number">2</span> * arrayLength);</span><br><span class="line">        arrayLength *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为theElement寻找插入位置, currentNode从新叶子节点开始向上移动</span></span><br><span class="line">    <span class="type">int</span> currentNode = ++heapSize;</span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="number">1</span> &amp;&amp; heap[currentNode / <span class="number">2</span>] &lt; theElement)</span><br><span class="line">    &#123;</span><br><span class="line">        heap[currentNode] = heap[currentNode / <span class="number">2</span>]; <span class="comment">// 元素向下移动</span></span><br><span class="line">        currentNode /= <span class="number">2</span>;                          <span class="comment">// currentNode移动到他的双亲</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap[currentNode] = theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> maxHeap&lt;T&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;<span class="comment">// 从大根堆删除最大的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heapSize == <span class="number">0</span>)   <span class="comment">// 大根堆是否为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最大的元素</span></span><br><span class="line">    heap[<span class="number">1</span>].~<span class="built_in">T</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到最后一个元素, 并将大根堆元素数量减1</span></span><br><span class="line">    T lastElement = heap[heapSize--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根节点开始, 为最后一个元素查找插入位置</span></span><br><span class="line">    <span class="type">int</span> currentNode = <span class="number">1</span>;    <span class="comment">// 当前双亲节点</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span>;          <span class="comment">// 当前孩子节点</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= heapSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// heap[child] 应该是 currentNode 更大的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对比 lastElement 是否可以插入到 currentNode</span></span><br><span class="line">        <span class="keyword">if</span> (lastElement &gt;= heap[child])</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">// 可以插入则直接结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不可以插入则继续循环</span></span><br><span class="line">        heap[currentNode] = heap[child]; <span class="comment">// 子节点向上移动</span></span><br><span class="line">        currentNode = child;             <span class="comment">// 当前指向节点移动到子节点</span></span><br><span class="line">        child *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[currentNode] = lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> maxHeap&lt;T&gt;::<span class="built_in">initialize</span>(T* theHeap, <span class="type">int</span> theSize)</span><br><span class="line">&#123;<span class="comment">// 在数组 theHeap[1:theSize] 中初始化大根堆</span></span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap = theHeap;</span><br><span class="line">    heapSize = theSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> root = heapSize / <span class="number">2</span>; root &gt;= <span class="number">1</span>; root--)</span><br><span class="line">    &#123;</span><br><span class="line">        T rootElement = heap[root];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给元素 rootElement 寻找位置</span></span><br><span class="line">        <span class="type">int</span> child = <span class="number">2</span> * root; <span class="comment">// 孩子 child 的双亲是 rootElement 的位置</span></span><br><span class="line">        <span class="comment">// 确定 rootElement 的位置</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt;= heapSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// heap[child] 找到孩子里更大的那一个</span></span><br><span class="line">            <span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>])</span><br><span class="line">                child++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否可以把 rootElement 插入到该位置</span></span><br><span class="line">            <span class="keyword">if</span> (rootElement &gt;= heap[child])</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不可以</span></span><br><span class="line">            heap[child / <span class="number">2</span>] = heap[child]; <span class="comment">// 孩子向上移动</span></span><br><span class="line">            child *= <span class="number">2</span>;                    <span class="comment">// 下移一层查看</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap[child / <span class="number">2</span>] = rootElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> maxHeap&lt;T&gt;::<span class="built_in">output</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heapSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-左高树"><a href="#2-左高树" class="headerlink" title="2.左高树"></a>2.左高树</h1><h2 id="2-1-高度优先左高树和重量优先左高树"><a href="#2-1-高度优先左高树和重量优先左高树" class="headerlink" title="2.1 高度优先左高树和重量优先左高树"></a>2.1 高度优先左高树和重量优先左高树</h2><p>　　左高树合并操作的时间复杂度更低，适合需要合并操作较多的数据</p>
<p>　　定义一类特殊的节点为<strong>外部节点</strong>来代替空子树，其余节点为<strong>内部节点</strong>。增加了外部节点的二叉树称为<strong>扩充二叉树</strong>。</p>
<p>　　<strong>定义距离s：</strong>s 是该节点到外部节点的<strong>最短路径</strong>。</p>
<p>　　<strong>定义重量w：</strong>w 是该节点<strong>重量的和</strong>，节点本身重量为1，节点的重量为自身重量与孩子重量的和。</p>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231010201410022-511791482.png" width="90%"></img></div>

<p>　　<strong>高度优先左高树</strong>（height-biased leftist tree，<strong>HBLT</strong>）：这个二叉树任何一个内部节点左孩子的 s 值都大于等于右孩子的 s 值。其中上图(a)就不是一棵左高树，因为它左侧子树的左孩子值为0，而右孩子值为1，下图是2个HBLT。</p>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231012164456821-508821702.png" width="60%"></img></div>

<p>　　<strong>重量优先左高树</strong>（weight-biased leftist tree，<strong>WBLT</strong>）：这个二叉树任何一个内部节点左孩子的 w 值都大于或等于右孩子的 w 值。</p>
<h2 id="2-2-HBLT的性质"><a href="#2-2-HBLT的性质" class="headerlink" title="2.2 HBLT的性质"></a>2.2 HBLT的性质</h2><ol>
<li>堆的性质：任意节点值的大小 ≤ 其孩子节点的大小（小根堆，也可以是 ≥ ）</li>
<li>左偏性质：左孩子的距离 s ≥ 右孩子的距离 s </li>
<li>任意节点的距离 s 都等于其右孩子的距离 + 1</li>
<li>一棵有 n 个节点的二叉树，根的距离dis ≤ long(n+1) - 1（距离最远就是满二叉树的情况，否则一定有更短路径出去）</li>
</ol>
<h2 id="2-3-HBLT的插入和删除"><a href="#2-3-HBLT的插入和删除" class="headerlink" title="2.3 HBLT的插入和删除"></a>2.3 HBLT的插入和删除</h2><p>　　插入相当于将已有的树和一棵仅有一个元素的树进行合并操作</p>
<p>　　删除相当于将左右两棵HBLT进行合并操作</p>
<h2 id="2-4-HBLT的合并（链式实现）"><a href="#2-4-HBLT的合并（链式实现）" class="headerlink" title="2.4 HBLT的合并（链式实现）"></a>2.4 HBLT的合并（链式实现）</h2><p> 　　用一张图解释合并的过程，我们需要把两棵树合并到 x 上</p>
<ul>
<li>对比 x 指向节点数值和 y 指向节点数值的大小</li>
<li>如果节点数值 x &lt; y，则将 x 指向的地址和 y 指向的地址交换</li>
<li>将 x 指针移动到 x 的右孩子位置</li>
</ul>
<p>　　这就是图左完整的递归过程，递归的过程实际上就是在比较两个左高树右侧孩子链的大小，并来回交换来保证堆的性质，所以整个递归应该是O(logm)+O(logn)的时间复杂度</p>
<ul>
<li>首先 x 移动到下一个位置指向元素 7，对比元素 7 和元素 8，元素 8 更大，所以指针指向的地址互换，元素 8 移动到右孩子的位置</li>
<li>然后 x 移动到下一个位置指向元素 6，对比元素 6 和元素 7，元素 7 更大，所以指针指向的地址呼唤，元素 7 移动到右孩子的位置</li>
<li>然后 x 移动到下一个位置指向 NULL，因为 x 指向 NULL，所以直接将 x 指向 y 所指向的地址，递归结束</li>
</ul>
<p>　　最后一步是回溯，已经完成元素的插入后，需要维护左高树的性质，回溯的过程就是根据距离不断交换孩子节点的位置，保证左孩子的距离 ≥ 右孩子的距离</p>
<div align=center><img src="/images/数据结构/大根堆和左高树/3219843-20231012155602186-1451343428.png" width="80%"></img></div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> maxHblt&lt;T&gt;::<span class="built_in">merged</span>(binaryTreeNode&lt;pair&lt;<span class="type">int</span>, T&gt; &gt;*&amp; x, binaryTreeNode&lt;pair&lt;<span class="type">int</span>, T&gt; &gt;*&amp; y)</span><br><span class="line">&#123;<span class="comment">// 合并两棵左高树, x是自己的根节点地址, y是传入的根节点地址</span></span><br><span class="line">    <span class="keyword">if</span> (y == <span class="literal">NULL</span>)   <span class="comment">// 如果传入的树为空, 不需要操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span>)   <span class="comment">// 如果x节点为空, 则直接让该节点的值等于传入节点的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = y; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护堆的性质, 保证 x 是更大的那一个</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;element.second &lt; y-&gt;element.second)</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来进行递归, x 向其右孩子移动一位</span></span><br><span class="line">    <span class="built_in">merged</span>(x-&gt;rightChild, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后是回溯的过程, 需要维护左高树的性质, 保证左孩子的路径长度大于右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;leftChild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">// 左树为空直接交换即可</span></span><br><span class="line">        x-&gt;leftChild = x-&gt;rightChild;</span><br><span class="line">        x-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">        x-&gt;element.first = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 左树不为空则对比他们的路径长度</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;leftChild-&gt;element.first &lt; x-&gt;rightChild-&gt;element.first)</span><br><span class="line">            <span class="built_in">swap</span>(x-&gt;leftChild, x-&gt;rightChild);</span><br><span class="line">        <span class="comment">// 最后更新路径长度</span></span><br><span class="line">        x-&gt;element.first = x-&gt;rightChild-&gt;element.first + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-HBLT的初始化"><a href="#2-5-HBLT的初始化" class="headerlink" title="2.5 HBLT的初始化"></a>2.5 HBLT的初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> maxHblt&lt;T&gt;::<span class="built_in">initialize</span>(T* theElements, <span class="type">int</span> theSize)</span><br><span class="line">&#123;<span class="comment">// 根据给定的数组初始化左高树</span></span><br><span class="line">    arrayQueue&lt;binaryTreeNode&lt;pair&lt;<span class="type">int</span>, T&gt; &gt;*&gt; <span class="built_in">q</span>(theSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化树的队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= theSize; i++)</span><br><span class="line">        <span class="comment">// 建立一个只有一个节点的树插入队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">int</span>, T&gt; &gt;</span><br><span class="line">            (<span class="built_in">pair</span>&lt;<span class="type">int</span>, T&gt;(<span class="number">1</span>, theElements[i])));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中重复取出树进行合并操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= theSize - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;<span class="comment">// 从队列中取出2个树</span></span><br><span class="line">        binaryTreeNode&lt;pair&lt;<span class="type">int</span>, T&gt; &gt;* b = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        binaryTreeNode&lt;pair&lt;<span class="type">int</span>, T&gt; &gt;* c = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">merged</span>(b, c);</span><br><span class="line">        <span class="comment">// 把合并后的树插入队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (theSize &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = q.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;treeSize = theSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>mxwu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://mingxuanwu.com/2023/10/12/202310121708/">https://mingxuanwu.com/2023/10/12/202310121708/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2023 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"># 数据结构</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/10/13/202310132010/">【数据结构】6.搜索树</a>
            
            
            <a class="next" rel="next" href="/2023/10/10/202310101053/">【数据结构】4.二叉树</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mxwu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>